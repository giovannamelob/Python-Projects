# -*- coding: utf-8 -*-
"""Time Series Data Analysis on Ethereum Prices

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wXe8K7-QAIuoEzObeNVyELuQILHV_G7a

# Time series with pandas
"""

pip install statsmodels

# import and download data

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

eth = pd.read_csv('https://github.com/hitoshinagano/data/blob/main/ETHUSDT_2021.gzip?raw=true',
                  compression='gzip', parse_dates=['open_time'], index_col='open_time')

print(eth.head())  # print first few rows
print(eth.info())  # check for data types and missing values

# Index validation

eth.index.is_unique
eth.index.is_monotonic_increasing  # check if the index is sorted in ascending order
eth.shape

# Handling dupicates or non monotonic indexes

if not eth.index.is_unique:
    eth = eth[~eth.index.duplicated(keep='first')]  # Remove duplicates

if not eth.index.is_monotonic_increasing:
    eth = eth.sort_index()  # Sort the index to make it monotonic

"""## Visualization"""

eth.close.plot(figsize=(20, 5))  # Plotting the 'close' column
plt.title('Ethereum Close Price Over Time')
plt.xlabel('Date')
plt.ylabel('Close Price (USD)')
plt.show()

# Plot moving averages

eth['MA50'] = eth['close'].rolling(window=50).mean()
eth['MA200'] = eth['close'].rolling(window=200).mean()

eth[['close', 'MA50', 'MA200']].plot(figsize=(20, 5))
plt.title('Ethereum Close Price with 50-day and 200-day Moving Averages')
plt.xlabel('Date')
plt.ylabel('Close Price (USD)')
plt.show()

"""## Indexing and slicing"""

# Dynamic time slicing to look at different months or weeks

def plot_time_slice(df, start, end):
    sliced_df = df.loc[start:end]
    sliced_df['close'].plot(figsize=(20, 5))
    plt.title(f'Ethereum Close Price from {start} to {end}')
    plt.xlabel('Date')
    plt.ylabel('Close Price (USD)')
    plt.show()

plot_time_slice(eth, '2021-01', '2021-02')  # Example: plot for January to February 2021

"""## Missing data"""

eth.reset_index()['open_time'].diff().value_counts()  # Checking time gaps

# plot missing data gaps

eth.loc['2021-04-20 00': '2021-04-20 06', 'close'].plot(figsize=(15, 5), ls='', marker='x');

# reindexing data to fill gaps

start_end_range = pd.date_range(start=eth.index[0], end=eth.index[-1], freq='1min')
eth = eth.reindex(start_end_range)

# Forward fill missing values

eth.fillna(method='ffill', inplace=True)

# Option 1: Interpolation (default: linear)
# eth2 = eth.interpolate()

# Option 2: Forward fill
# eth2 = eth.fillna(method='ffill')

# Option 3: Backward fill
# eth2 = eth.fillna(method='bfill')

"""# Filling Missing Values
In this step, we could use three different approaches to handle missing values:
1. Interpolation: Useful when we expect values to change gradually over time.
2. Forward Fill: Fills gaps with the last known value, which is useful in financial data.
3. Backward Fill: Fills gaps with the next known value, which is a conservative approach.

"""

# Resampling and Aggregation

eth['close'].resample('1h').agg(['mean', 'std'])  # Hourly resampling
eth['close'].resample('1d').ohlc()  # OHLC data resampling (daily)

# resampling and 7-day moving average

daily_close = eth['close'].resample('1d').mean()
rolling_7d = daily_close.rolling(7).mean()

rolling_7d.plot(figsize=(15, 6), marker='x', label='7-Day Moving Average')
daily_close.plot(figsize=(15, 6), label='Daily Mean')
plt.title('Daily Close Price vs 7-Day Moving Average')
plt.xlabel('Date')
plt.ylabel('Close Price (USD)')
plt.legend()
plt.show()

# rolling statistics to observe trends in volatility over time

eth['rolling_mean'] = eth['close'].rolling(window=50).mean()
eth['rolling_std'] = eth['close'].rolling(window=50).std()

eth[['close', 'rolling_mean', 'rolling_std']].plot(figsize=(20, 5))
plt.title('Ethereum Close Price with Rolling Mean and Standard Deviation')
plt.show()

# decompose the time series into trend, seasonal, and residual components

from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(eth['close'].dropna(), model='additive', period=1440)  # Assuming daily periodicity
decomposition.plot()
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Ensure 'close' column is numeric and drop any missing values
eth['close'] = pd.to_numeric(eth['close'], errors='coerce')
eth_clean = eth['close'].dropna()

# Check if the data is stationary (if needed, you can apply differencing)
eth_diff = eth_clean.diff().dropna()

# Plot Autocorrelation
plot_acf(eth_diff, lags=50)
plt.title('Autocorrelation of Ethereum Close Prices')
plt.show()

# Plot Partial Autocorrelation
plot_pacf(eth_diff, lags=50)
plt.title('Partial Autocorrelation of Ethereum Close Prices')
plt.show()

# ARIMA model to predict future values based on the time series

from statsmodels.tsa.arima.model import ARIMA

model = ARIMA(eth['close'].dropna(), order=(5,1,0))  # ARIMA(5,1,0) model
model_fit = model.fit()
print(model_fit.summary())

eth['forecast'] = model_fit.predict(start=len(eth), end=len(eth) + 30, dynamic=True)
eth[['close', 'forecast']].plot(figsize=(20, 5))
plt.title('Ethereum Close Price Prediction')
plt.show()